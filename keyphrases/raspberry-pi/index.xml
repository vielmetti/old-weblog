<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Raspberry Pi on Vacuum weblog from Edward Vielmetti</title>
    <link>http://vielmetti.github.io/keyphrases/raspberry-pi/</link>
    <description>Recent content in Raspberry Pi on Vacuum weblog from Edward Vielmetti</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Sep 2015 00:05:00 -0400</lastBuildDate>
    <atom:link href="http://vielmetti.github.io/keyphrases/raspberry-pi/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Old code and old tools</title>
      <link>http://vielmetti.github.io/post/2015/2015-09-14-old-code-and-old-tools/</link>
      <pubDate>Mon, 14 Sep 2015 00:05:00 -0400</pubDate>
      
      <guid>http://vielmetti.github.io/post/2015/2015-09-14-old-code-and-old-tools/</guid>
      <description>&lt;p&gt;One of the problems with old codebases is that they are missing
modern tooling for automated builds, automated testing, and the
like.&lt;/p&gt;

&lt;p&gt;A second problem with old code is that the maintainers (absent
modern tooling) may not know or recognize what dependencies they
have.&lt;/p&gt;

&lt;p&gt;If an old package is not mostly self-contained, it&amp;rsquo;s likely to
have dependencies on other old code. This makes it hard to build,
as those older dependencies have either gone offline or have mutated
so that the old package doesn&amp;rsquo;t work with the new releases.&lt;/p&gt;

&lt;p&gt;To confound the matter even more, the newer tools for automated
builds, automated tests and so forth have their own sets of complex
dependencies, so much so that unless you are around some team that
has already absorbed these systems that you are unlikely to grasp
all of their deeply interconnected complexities.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s easy to cascade into a deep chasm of interlocking dependencies,
yielding enough complexity in the build process to frustrated people
who really care more about the code than how it&amp;rsquo;s packaged for distribution.&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;I&amp;rsquo;ve been working this weekend on &lt;code&gt;tidy-html5&lt;/code&gt;. It has a Makefile
that&amp;rsquo;s generated by CMake, and its documentation is built with
a combination of xsltproc and Doxygen. As dependencies go that&amp;rsquo;s
not too bad, but the problem starts because the codebase lay dormant
for a couple of years, and somewhere between three and six years
of net development and build tooling efforts have passed it by.&lt;/p&gt;

&lt;p&gt;There was no Dockerfile for the project, so I wrote one to see if I
could get it to build and could understand all of the build dependencies.
That took a dozen tries, but eventually something went through to
completion.&lt;/p&gt;

&lt;p&gt;The first thing I noted was that it not only depended on CMake but
also a particularly relatively recent version of CMake. Ditto for
Doxygen - not any elderly Doxygen will do, but only a relatively
recent build. Doxygen has its own dependencies, lots of them - about
a gigabyte of code to download and install.&lt;/p&gt;

&lt;p&gt;Next was to pick up on a previous effort to build the whole thing under
Travis CI. Now I have a relatively old build system that doesn&amp;rsquo;t
have these old dependencies so I have to drag them in, and not only
drag in some version but a particularly new version.&lt;/p&gt;

&lt;p&gt;Dependencies satisfied, it&amp;rsquo;s time to build. I want this to work on my
Raspberry Pi, so I build it there, and discover that the version of
Doxygen there is too old (oops) so it doesn&amp;rsquo;t build the docs at all,
never mind the cheery message from the build script that claims
&amp;ldquo;TidyLib API documentation has been built&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Next, to test. Does it pass all of its tests? Well, there is a test
directory with a bunch of test cases, but the documentation says things
like&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Of course some of the tests were to say avoid a segfault found.
Other tests were to visually compare the original input test file
in a browser, with how the new output displayed in a browser. This
is a purely VISUAL compare, and can not be done in code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Frankly, a test that can&amp;rsquo;t be done in code is one that I can&amp;rsquo;t run
in finite time. I build all of the tests, diff them with the reference
directory, and hope that the differences (there are a few) aren&amp;rsquo;t fatal.&lt;/p&gt;

&lt;p&gt;You see where this is going&amp;hellip;&lt;/p&gt;

&lt;p&gt;Frankly, it&amp;rsquo;s hard to get all of the tooling right. Travis CI has all of
its own quirks, and you have to set up a build correctly to get correct
build completion results. Once the build happens, you want some sort of
test harness to take all of these test cases and turn them into red lights
and green lights on your screen, and I don&amp;rsquo;t have that yet. Building
binaries is yet another task - one project contributor put together a
Jenkins install to take on that task.  And so forth.&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;The piece of this that I care about is twofold. &lt;code&gt;tidy&lt;/code&gt; as it stands now
is frozen in 2009, and that&amp;rsquo;s before HTML5. &lt;code&gt;tidy-html5&lt;/code&gt; is caught in flux,
with a successful project rescue to get it to build at all, but not yet
the full-on automation and test infrastructure that projects like &lt;code&gt;docker&lt;/code&gt;
or &lt;code&gt;node.js&lt;/code&gt; have that allow for ferocious parallel development with
reasonable test and integration coverage.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;tidy&lt;/code&gt; project is very old (20 yrs), and if it&amp;rsquo;s going to pass
a full suite of automated tests on every check-in for every platform,
that&amp;rsquo;s going to take some consolidated effort - both by people who
care about the code (but not so much how it&amp;rsquo;s packaged) and by people
who care about the packaging (so that they can use the code). Not
only does the code need to evolve, but the build tools around the
code need to move forward.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>