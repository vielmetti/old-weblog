<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vacuum weblog from Edward Vielmetti</title>
    <link>http://vielmetti.github.io/keyphrases/continuous-integration/index.xml</link>
    <description>Recent content on Vacuum weblog from Edward Vielmetti</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://vielmetti.github.io/keyphrases/continuous-integration/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Snap CI</title>
      <link>http://vielmetti.github.io/post/2015/2015-09-22-snap-ci/</link>
      <pubDate>Tue, 22 Sep 2015 07:00:00 -0400</pubDate>
      
      <guid>http://vielmetti.github.io/post/2015/2015-09-22-snap-ci/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://snap-ci.com&#34;&gt;Snap CI&lt;/a&gt; is a cloud-based continuous integration system. Like
Travis CI, which I have written about &lt;a href=&#34;http://vielmetti.github.io/post/2015/2015-09-16-travis-ci/&#34;&gt;here&lt;/a&gt;,
it lives in the cloud, lets you run programs triggered by GitHub commits, and
offers a testing environment for free for open source projects which lets you
familiarize yourself with the system before deciding to pay for it for your
non-open-source efforts.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m looking at all of these tools now because this weblog is now managed through
a process that involves checking things into Github, which makes it completely
suitable for automation for common tasks every time I save a file. (Spell checking,
link checking, really any kind of quality control you can imagine reducing to
a tiny shell script.)&lt;/p&gt;

&lt;p&gt;Like Travis CI, Snap CI lets you automate the build process. Where it diverges
(and where it&amp;rsquo;s interesting) is that the build process is only the first part of
a multi-stage pipeline that includes deployment at the end of the task only when
a set of human decisions have been made as to whether the thing you made is ready
to be shared.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&#34;https://blog.snap-ci.com/blog/2014/07/22/why-snapci-and-travisci-are-not-same-thing/&#34;&gt;Snap CI blog post&lt;/a&gt;
on why Travis CI and Snap CI are not the same thing is from Snap CI and it&amp;rsquo;s a useful
overview.&lt;/p&gt;

&lt;p&gt;The downside of multi-stage pipelines for deployment is that they are very hard to
automate correctly, and very hard to demonstrate correct behavior with open source
projects that generally struggle to have any automated test facilities at all. So
while Travis CI is a very good fit for open source components (and has attracted a
whole sub-industry of writing &lt;code&gt;.travis.yml&lt;/code&gt; files to support those), it really doesn&amp;rsquo;t
have the whole &amp;ldquo;continuous deployment&amp;rdquo; pattern sorted out. And while Snap CI looks
like it would be great for saying &amp;ldquo;once we&amp;rsquo;re happy with this, push it out to the world&amp;rdquo;,
that setup is not easy to pick up simply by inspecting other projects that have done it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Into the matrix with Travis CI</title>
      <link>http://vielmetti.github.io/post/2015/2015-09-16-travis-ci/</link>
      <pubDate>Wed, 16 Sep 2015 09:22:00 -0400</pubDate>
      
      <guid>http://vielmetti.github.io/post/2015/2015-09-16-travis-ci/</guid>
      <description>

&lt;p&gt;Travis CI is a continuous integration tool, a description which means nothing
to people who have never used it. &amp;ldquo;Continuous integration&amp;rdquo; is one of these
industry phrases that doesn&amp;rsquo;t serve to illuminate the problem that it describes.&lt;/p&gt;

&lt;p&gt;Why would you care? Well, you&amp;rsquo;re working on a project with a bunch of other
people, and it&amp;rsquo;s kind of complicated. It might depend on some
&lt;a href=&#34;http://vielmetti.github.io/post/2015/2015-09-14-old-code-and-old-tools/&#34;&gt;old code&lt;/a&gt;
that&amp;rsquo;s fragile and should be tested all the time when it changes, or it might depend
some brand-spanking new code that doesn&amp;rsquo;t quite work and you know it
doesn&amp;rsquo;t work yet but you want the test system to be less tedious.&lt;/p&gt;

&lt;p&gt;What else looks like this?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://circleci.com/&#34;&gt;CircleCI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://snap-ci.com/&#34;&gt;Snap CI&lt;/a&gt; by ThoughtWorks&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.solanolabs.com/&#34;&gt;Solano&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.appveyor.com/&#34;&gt;Appveyor&lt;/a&gt; (for Windows)&lt;/li&gt;
&lt;li&gt;Jenkins (self hosted)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What does this look like from a workflow perspective? Every time you check in a
file, the whole system builds, and all of the tests you have configured run.
With proper configuration you can build a matrix of versions or configurations
to test, so instead of a test running on a single system it can run on
3x3 or 2x4 or even 3x5x2 configurations.&lt;/p&gt;

&lt;h3 id=&#34;ruby&#34;&gt;Ruby&lt;/h3&gt;

&lt;p&gt;Travis CI&amp;rsquo;s default langauge is Ruby, and a lot of its tooling is written
in Ruby, so its Ruby support is quite good.&lt;/p&gt;

&lt;p&gt;Need a bunch of versions of Ruby? Use &lt;code&gt;rvm&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.travis-ci.com/user/languages/ruby/&#34;&gt;Building a Ruby Project, Travis CI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;c-and-c&#34;&gt;C and C++&lt;/h3&gt;

&lt;p&gt;The version of gcc and g++ on the default systems is 4.6, and you can
pull in 4.8 through &amp;lsquo;apt&amp;rsquo;, but you currently have to pick up 4.8 through
the &lt;code&gt;ubuntu-toolchain-r-test&lt;/code&gt; source and not simply by picking a gcc version.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rla/fast-feed/blob/master/.travis.yml&#34;&gt;rla/fast-feed/.travis.yml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;go-golang&#34;&gt;Go (golang)&lt;/h3&gt;

&lt;p&gt;Go (golang) has not gone through a lot of versions yet, and its latest 1.5
build is written in Go. Because the language is so young, there is not lots
of old code to port, and thus not too many version dependencies in libraries
to worry about yet.&lt;/p&gt;

&lt;p&gt;Testing two versions of Go (golang) plus Linux and Mac is easy, and the
configuration file doesn&amp;rsquo;t have to do anything funky.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/miekg/mmark/fast-feed/blob/master/.travis.yml&#34;&gt;miekg/mmark/.travis.yml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;nodejs&#34;&gt;NodeJS&lt;/h3&gt;

&lt;p&gt;Node 4.0 is new, and the source currently of a fair bit of porting efforts as
a lot of things have broken not in the language but in its libraries. Fortunately,
the nodejs and iojs split has been reconciled, but unfortunately there&amp;rsquo;s about
six months of reunification work to be done.&lt;/p&gt;

&lt;p&gt;If you are porting or building to NodeJS 4.0, you have to drag in gcc 4.8. Previous
versions of gcc/g++ aren&amp;rsquo;t capable of coping with the C++11 constructs that are
in V8 and (especially) in &lt;code&gt;nan&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;NodeJS 4.0 on Mac? In addition to gcc 4.8, you have to drag in nvm.
The approachable way is to pull in the source from Github that lives
at &lt;code&gt;https://github.com/creationix/nvm.git&lt;/code&gt;, build it, and then use the
thing that you just built to subsequently pull in the right version of Node.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rla/fast-feed/blob/master/.travis.yml&#34;&gt;rla/fast-feed/.travis.yml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sass/node-sass/blob/master/.travis.yml&#34;&gt;sass/node-sass/.travis.yml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;

&lt;p&gt;Python 2 and Python 3 are both available on Travis CI, including even
the latest Python 3.5.&lt;/p&gt;

&lt;p&gt;If you need three versions of Python plus three versions of Django:
use &amp;lsquo;env&amp;rsquo; to drive &amp;lsquo;pip&amp;rsquo;, and &amp;lsquo;matrix&amp;rsquo; to skip some builds where you
know that the combinations don&amp;rsquo;t work.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(datadesk/django-softhyphen)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lots and lots of Python versions, with different dependencies for
each version? The &lt;code&gt;tornado&lt;/code&gt; package has that.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(tornadoweb/tornado)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Looking to test Django plus Postgres?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(&lt;a href=&#34;http://blog.schwuk.com/2014/06/13/using-travis-ci-for-testing-django-projects/&#34;&gt;http://blog.schwuk.com/2014/06/13/using-travis-ci-for-testing-django-projects/&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;java&#34;&gt;Java&lt;/h3&gt;

&lt;p&gt;Java is supported.&lt;/p&gt;

&lt;p&gt;If you need Java 8 in a particular version, see the below issue on Github Issues.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/travis-ci/travis-ci/issues/4042&#34;&gt;Java 8 version update and bug&lt;/a&gt;,
Github issues.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;fortran&#34;&gt;Fortran&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;re building scientific codes, Fortran is available through the &lt;code&gt;apt&lt;/code&gt;
mechanism.&lt;/p&gt;

&lt;h3 id=&#34;prolog&#34;&gt;Prolog&lt;/h3&gt;

&lt;p&gt;Prolog? Bring it in with apt-add-repository and apt-get. This is illustrative
of Travis CI&amp;rsquo;s ability to incorporate nearly any language, since you can install
new compilers and interpreters via package systems and then run them.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(rla/simple-template)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;multiple-langauges&#34;&gt;Multiple langauges&lt;/h3&gt;

&lt;p&gt;Two versions of Go plus Python plus an external dependency that&amp;rsquo;s being flaky?
Use &lt;code&gt;language: python&lt;/code&gt; because it&amp;rsquo;s easier to install &lt;code&gt;go&lt;/code&gt; from package
managers than it is to drag in the whole complex python multi-version infrastructure
from scratch.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(miekg/mmark, in progress)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;os-x&#34;&gt;OS X&lt;/h3&gt;

&lt;p&gt;Use &amp;lsquo;osx_image&amp;rsquo; to tweak the version of &amp;lsquo;osx&amp;rsquo; that you get.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(&lt;a href=&#34;http://docs.travis-ci.com/user/osx-ci-environment/&#34;&gt;http://docs.travis-ci.com/user/osx-ci-environment/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;(&lt;a href=&#34;http://blog.travis-ci.com/2015-09-09-xcode7-gm/&#34;&gt;http://blog.travis-ci.com/2015-09-09-xcode7-gm/&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;both-linux-and-mac-in-general&#34;&gt;Both Linux and Mac, in general&lt;/h3&gt;

&lt;p&gt;Go is easy. (miekg/mmark)&lt;/p&gt;

&lt;p&gt;Node requires bringing in nvm and gcc 4.8. (rla/fastfeed)&lt;/p&gt;

&lt;p&gt;Python &amp;hellip; (don&amp;rsquo;t know)&lt;/p&gt;

&lt;p&gt;Prolog &amp;hellip; (don&amp;rsquo;t know)&lt;/p&gt;

&lt;p&gt;Ruby &amp;hellip; (should work pretty well, but not tested)&lt;/p&gt;

&lt;h2 id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;Thanks to the following people for their help: Raivo Laanemets (@RaivoL),
Mohan Kartha (@mckartha), Chris Dzombak (@cdzombak), &amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Old code and old tools</title>
      <link>http://vielmetti.github.io/post/2015/2015-09-14-old-code-and-old-tools/</link>
      <pubDate>Mon, 14 Sep 2015 00:05:00 -0400</pubDate>
      
      <guid>http://vielmetti.github.io/post/2015/2015-09-14-old-code-and-old-tools/</guid>
      <description>&lt;p&gt;One of the problems with old codebases is that they are missing
modern tooling for automated builds, automated testing, and the
like.&lt;/p&gt;

&lt;p&gt;A second problem with old code is that the maintainers (absent
modern tooling) may not know or recognize what dependencies they
have.&lt;/p&gt;

&lt;p&gt;If an old package is not mostly self-contained, it&amp;rsquo;s likely to
have dependencies on other old code. This makes it hard to build,
as those older dependencies have either gone offline or have mutated
so that the old package doesn&amp;rsquo;t work with the new releases.&lt;/p&gt;

&lt;p&gt;To confound the matter even more, the newer tools for automated
builds, automated tests and so forth have their own sets of complex
dependencies, so much so that unless you are around some team that
has already absorbed these systems that you are unlikely to grasp
all of their deeply interconnected complexities.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s easy to cascade into a deep chasm of interlocking dependencies,
yielding enough complexity in the build process to frustrated people
who really care more about the code than how it&amp;rsquo;s packaged for distribution.&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;I&amp;rsquo;ve been working this weekend on &lt;code&gt;tidy-html5&lt;/code&gt;. It has a Makefile
that&amp;rsquo;s generated by CMake, and its documentation is built with
a combination of xsltproc and Doxygen. As dependencies go that&amp;rsquo;s
not too bad, but the problem starts because the codebase lay dormant
for a couple of years, and somewhere between three and six years
of net development and build tooling efforts have passed it by.&lt;/p&gt;

&lt;p&gt;There was no Dockerfile for the project, so I wrote one to see if I
could get it to build and could understand all of the build dependencies.
That took a dozen tries, but eventually something went through to
completion.&lt;/p&gt;

&lt;p&gt;The first thing I noted was that it not only depended on CMake but
also a particularly relatively recent version of CMake. Ditto for
Doxygen - not any elderly Doxygen will do, but only a relatively
recent build. Doxygen has its own dependencies, lots of them - about
a gigabyte of code to download and install.&lt;/p&gt;

&lt;p&gt;Next was to pick up on a previous effort to build the whole thing under
Travis CI. Now I have a relatively old build system that doesn&amp;rsquo;t
have these old dependencies so I have to drag them in, and not only
drag in some version but a particularly new version.&lt;/p&gt;

&lt;p&gt;Dependencies satisfied, it&amp;rsquo;s time to build. I want this to work on my
Raspberry Pi, so I build it there, and discover that the version of
Doxygen there is too old (oops) so it doesn&amp;rsquo;t build the docs at all,
never mind the cheery message from the build script that claims
&amp;ldquo;TidyLib API documentation has been built&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Next, to test. Does it pass all of its tests? Well, there is a test
directory with a bunch of test cases, but the documentation says things
like&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Of course some of the tests were to say avoid a segfault found.
Other tests were to visually compare the original input test file
in a browser, with how the new output displayed in a browser. This
is a purely VISUAL compare, and can not be done in code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Frankly, a test that can&amp;rsquo;t be done in code is one that I can&amp;rsquo;t run
in finite time. I build all of the tests, diff them with the reference
directory, and hope that the differences (there are a few) aren&amp;rsquo;t fatal.&lt;/p&gt;

&lt;p&gt;You see where this is going&amp;hellip;&lt;/p&gt;

&lt;p&gt;Frankly, it&amp;rsquo;s hard to get all of the tooling right. Travis CI has all of
its own quirks, and you have to set up a build correctly to get correct
build completion results. Once the build happens, you want some sort of
test harness to take all of these test cases and turn them into red lights
and green lights on your screen, and I don&amp;rsquo;t have that yet. Building
binaries is yet another task - one project contributor put together a
Jenkins install to take on that task.  And so forth.&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;The piece of this that I care about is twofold. &lt;code&gt;tidy&lt;/code&gt; as it stands now
is frozen in 2009, and that&amp;rsquo;s before HTML5. &lt;code&gt;tidy-html5&lt;/code&gt; is caught in flux,
with a successful project rescue to get it to build at all, but not yet
the full-on automation and test infrastructure that projects like &lt;code&gt;docker&lt;/code&gt;
or &lt;code&gt;node.js&lt;/code&gt; have that allow for ferocious parallel development with
reasonable test and integration coverage.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;tidy&lt;/code&gt; project is very old (20 yrs), and if it&amp;rsquo;s going to pass
a full suite of automated tests on every check-in for every platform,
that&amp;rsquo;s going to take some consolidated effort - both by people who
care about the code (but not so much how it&amp;rsquo;s packaged) and by people
who care about the packaging (so that they can use the code). Not
only does the code need to evolve, but the build tools around the
code need to move forward.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>