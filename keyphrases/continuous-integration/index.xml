<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Continuous Integration on Vacuum weblog from Edward Vielmetti</title>
    <link>http://vielmetti.github.io/keyphrases/continuous-integration/</link>
    <description>Recent content in Continuous Integration on Vacuum weblog from Edward Vielmetti</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 22 Sep 2015 07:00:00 -0400</lastBuildDate>
    
	<atom:link href="http://vielmetti.github.io/keyphrases/continuous-integration/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Snap CI</title>
      <link>http://vielmetti.github.io/post/2015/2015-09-22-snap-ci/</link>
      <pubDate>Tue, 22 Sep 2015 07:00:00 -0400</pubDate>
      
      <guid>http://vielmetti.github.io/post/2015/2015-09-22-snap-ci/</guid>
      <description>Snap CI is a cloud-based continuous integration system. Like Travis CI, which I have written about here, it lives in the cloud, lets you run programs triggered by GitHub commits, and offers a testing environment for free for open source projects which lets you familiarize yourself with the system before deciding to pay for it for your non-open-source efforts.
I&amp;rsquo;m looking at all of these tools now because this weblog is now managed through a process that involves checking things into Github, which makes it completely suitable for automation for common tasks every time I save a file.</description>
    </item>
    
    <item>
      <title>Into the matrix with Travis CI</title>
      <link>http://vielmetti.github.io/post/2015/2015-09-16-travis-ci/</link>
      <pubDate>Wed, 16 Sep 2015 09:22:00 -0400</pubDate>
      
      <guid>http://vielmetti.github.io/post/2015/2015-09-16-travis-ci/</guid>
      <description>Travis CI is a continuous integration tool, a description which means nothing to people who have never used it. &amp;ldquo;Continuous integration&amp;rdquo; is one of these industry phrases that doesn&amp;rsquo;t serve to illuminate the problem that it describes.
Why would you care? Well, you&amp;rsquo;re working on a project with a bunch of other people, and it&amp;rsquo;s kind of complicated. It might depend on some old code that&amp;rsquo;s fragile and should be tested all the time when it changes, or it might depend some brand-spanking new code that doesn&amp;rsquo;t quite work and you know it doesn&amp;rsquo;t work yet but you want the test system to be less tedious.</description>
    </item>
    
    <item>
      <title>Old code and old tools</title>
      <link>http://vielmetti.github.io/post/2015/2015-09-14-old-code-and-old-tools/</link>
      <pubDate>Mon, 14 Sep 2015 00:05:00 -0400</pubDate>
      
      <guid>http://vielmetti.github.io/post/2015/2015-09-14-old-code-and-old-tools/</guid>
      <description>One of the problems with old codebases is that they are missing modern tooling for automated builds, automated testing, and the like.
A second problem with old code is that the maintainers (absent modern tooling) may not know or recognize what dependencies they have.
If an old package is not mostly self-contained, it&amp;rsquo;s likely to have dependencies on other old code. This makes it hard to build, as those older dependencies have either gone offline or have mutated so that the old package doesn&amp;rsquo;t work with the new releases.</description>
    </item>
    
  </channel>
</rss>